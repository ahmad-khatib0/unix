Two types of file links are available in Linux: A symbolic link And  A hard link

A symbolic link, also called a soft link, is simply a physical file that points
  to another file somewhere in the virtual directory structure. The two
  symbolically linked together files do not share the same contents.

Another way to tell that these linked files are separate physical files is by viewing their inode 
  numbers. The inode number of a file or directory is a unique identification number that the kernel 
  assigns to each object in the filesystem. To view a file or directory's inode number, 
  add the -i parameter to the ls command:
$ ls -i *test_file

A hard link creates a separate virtual file that contains information about the original file and 
  where to locate it. However, the two files are actually the same physical file. To create a hard 
  link, again the original file must preexist, except that this time no parameter is needed on the 
  ln command:        $ ln test_one hlink_test_one

NOTE: You can only create a hard link between files on the same physical medium. To create 
  a link between files under separate physical mediums, you must use a symbolic link.

NOTE: moving the file changes the name from fall to fzll but it keeps the same inode 
  number and timestamp value. This is because mv affects only a file's name.

NOTE: the less command name comes from the phrase â€œless is moreâ€) ðŸ˜„ ðŸ˜„.


The GNU ps command that's used in Linux systems supports three different
  types of command-line parameters:
. . Unix-style parameters, which are preceded by a dash
. . BSD-style parameters, which are not preceded by a dash
. . GNU long parameters, which are preceded by a double dash

The ps command columns: 
  UID: The user responsible for launching the process
  PID: The process ID of the process
  PPID: The PID of the parent process (if a process is started by another process)
  C: Processor utilization over the lifetime of the process
  STIME: The system time when the process started
  TTY: The terminal device from which the process was launched
  TIME: The cumulative CPU time required to run the process
  CMD: The name of the program that was started

When using: ps -l # extra columns will appear 
F: System flags assigned to the process by the kernel
S: The state of the process (O = running on processor; S = sleeping; R = runnable, 
   waiting to run; Z = zombie, process terminated but parent not available; T = process stopped)
PRI:   The priority of the process (higher numbers mean lower priority)
NI:    The nice value, used for determining priorities ADDR: The memory address of the process
SZ:    Approximate amount of swap space required if the process was swapped out
WCHAN: Address of the kernel function where the process is sleeping


The Linux filesystem combines all media disks into a single virtual directory. 
  Before you can use a new media disk on your system, you need to place it in the 
  virtual directory. This task is called mounting.

The mount command provides four pieces of information:
1 The device filename of the media
2 The mount point in the virtual directory where the media is mounted
3 The filesystem type
4 The access status of the mounted media

Linux recognizes numerous filesystem types. If you share removable media devices with 
  your Windows PCs, the types you're most likely to run into are:
vfat:    Windows FAT32 filesystem with support for long filenames
ntfs:    Windows advanced filesystem used in Windows NT and later operating systems
exfat:   Windows filesystem optimized for removable media
iso9660: The standard CD-ROM and DVD filesystem

Most USB memory sticks are formatted using the vfat filesystem. If you need to mount 
  a data CD or DVD, you'll have to use the iso9660 filesystem type.

The -o option ( mount command ) allows you to mount the filesystem with a comma-separated
  list of additional options. The popular options to use are as follows:
ro         : Mount as read-only.
rw         : Mount as read-write.
user       : Allow an ordinary user to mount the filesystem.
check=none : Mount the filesystem without performing an integrity check.
loop       : Mount a file.


The df command displays the following:
  The device location of the device
  How many 1024-byte blocks of data it can hold
  How many 1024-byte blocks are used
  How many 1024-byte blocks are available
  The amount of used space as a percentage
  The mount point where the device is mounted


When a child shell process is spawned, only some of the parent's environment is copied to the 
  child's shell environment. This can cause problems with items such as variables.


Process lists: 
$ pwd ; ls test* ; cd /etc ; pwd ; cd ; pwd ; ls my*

In the preceding example, the commands all executed one after another with no problems. However, 
  while using commands in this manner is called a list, it is not a process list. For a command list 
  to be considered a process list, the commands must be encased in parentheses:
$ (pwd ; ls test* ; cd /etc ; pwd ; cd ; pwd ; ls my*)

Though the parentheses addition may not appear to be a big difference, they do cause a very 
  different effect. Adding parentheses and turning the command list into a process list created 
  a subshell to execute the commands.

$ pwd ; ls test* ; cd /etc ; pwd ; cd ; pwd ; ls my* ; echo $BASH_SUBSHELL
At the very end of the commands' output, you can see the number zero (0)
  is displayed. This indicates a subshell was not created to execute these commands.

$ (pwd ; ls test* ; cd /etc ; pwd ; cd ; pwd ; ls my* ; echo $BASH_SUBSHELL)
In this case, the number one (1) displayed at the output's end. This indicates
  a subshell was indeed created and used for executing these commands.

create a grandchild subshell by embedding parentheses within a process list:
$ (pwd ; (echo $BASH_SUBSHELL))   # you'll see 2 at the end

When you have more than one background process running, there is some additional helpful information 
  to show which background job was started last. The most recently started job has a plus sign (+) 
  next to its job number in the jobs command's display. And the second newest process will have a 
  minus sign (-) to provide you with additional information.

Looking at co-processing
  Co-processing (i.e coproc sleep 10) does two things at the same time. It spawns a subshell in
  background mode and it executes a command within that subshell.

Looking at external commands
  An external command, sometimes called a filesystem command, is a program that exists outside of 
  the Bash shell. In other words, it is not built into the shell program. An external command 
  program is typically located in /bin , /usr/bin , /sbin , or /usr/sbin directories.
  Whenever an external command is executed, a child process is created. This action is termed forking. 
  Conveniently, the external command ps displays its current parent as well as its own forked 
  child processes:   $ ps -f 

Looking at built-in commands
  Built-in commands are different in that they do not need a child process to execute. They were 
  compiled into the shell, and thus are part of the shell's toolkit. No external program file 
  exists to run them. Both the cd and exit commands are built into the Bash shell. You can tell a
  command is built-in by using the type command:  $ type cd  # or $ which exit  

Be aware that some commands have multiple flavors. For example, both echo and pwd have a built-in 
  command flavor as well as an external command flavor. These flavors are slightly different. To see 
  multiple flavors for commands, use the -a option on the type command:  $ type -a echo 

Changing a global environment variable within a child shell does not affect
  the variable's value in the parent shell:
  
$ export my_variable="I am Global now"
$ echo $my_variable
$ bash
$ echo $my_variable # ->> I am Global now
$ my_variable="Null"
$ echo $my_variable # ->> Null
$ exit
$ echo $my_variable # ->> I am Global now

A child shell cannot even use the export command to change the parent shell's global variable's value
A child shell cannot even use the unset command to remove a parent env var


Setting the PATH Environment Variable:
  The PATH environment variable defines the directories it searches looking for commands and programs

Some script builders use the env command as the first line in a Bash shell script as in the 
  following: #!/usr/bin/env bash . The advantage of this method is that the env utility searches 
  for the bash shell program within the $PATH directories, making the script more portable to other 
  Linux distributions.

When you start a Bash shell by logging into the Linux system, by default Bash checks several files for 
  commands. These files are called startup files or environment files. Which startup files Bash processes 
  depends on the method you use to start the Bash shell. You can start a Bash shell in three ways:
- As a default login shell at login time
- As an interactive shell that is started by spawning a subshell
- As a noninteractive shell to run a script

When you log into the Linux system, the Bash shell starts as a login shell. The login shell 
  typically looks for five different startup files to process commands from:
  /etc/profile
  $HOME/.bash_profile
  $HOME/.bashrc
  $HOME/.bash_login
  $HOME/.profile
The /etc/profile file is the main default startup file for the Bash shell on the system. All users 
  on the system execute this startup file when they log in. The other four startup files are specific 
  for each user, located in the home ($HOME) directory, and can be customized for an individual user's
  requirements.

NOTE: 
  Be aware that some Linux distributions use pluggable authentication modules (PAM). In this case, 
  before the Bash shell is started, PAM files are processed, including ones that may contain environment 
  variables. PAM file examples include the /etc/environment file and the $HOME/.pam_environment file. 
  Find more information about PAM at www.linux-pam.org.

ls /etc/profile.d
Notice that several files are related to specific applications on the system. Most applications 
  create two startup files â€” one for the Bash shell (using the .sh extension) and one for the 
  C shell (using the .csh extension).

The .bash_profile startup file first checks to see if the startup file, .bashrc , is present in 
  the $ HOME directory. If it's there, the startup file executes the commands in it.

If Bash is started as an interactive shell, it doesn't process the /etc/profile file. 
  Instead, it it checks only for the .bashrc file in the user's $ HOME directory
  The .bashrc file does two things. First, it checks for a common bashrc file in the /etc directory. 
  Second, it provides a place for the user to enter personal command aliases 

Understanding the noninteractive shell process
  The last type of shell is a noninteractive subshell. This is the shell where the system can start 
  to execute a shell script. This is different in that there isn't a CLI prompt to worry about. 
  However, you may want to run specific startup commands each time you start a script on your system.
  To accommodate that situation, the Bash shell provides the BASH_ENV environment variable. When the 
  shell starts a noninteractive subshell process, it checks this environment variable for the startup 
  file name to execute. If one is present, the shell executes the file's commands, which
  typically include variables set for the shell scripts.

So if the BASH_ENV variable isn't set ( printenv BASH_ENV ), how do the shell scripts get their 
  environment variables? Remember that some shell script execution methods start a subshell, also 
  called a child shell. A child shell inherits its parent shell's exported variables. For example, 
  if the parent shell was a login shell and had variables set and exported in the /etc/profile file, 
  /etc/profile.d/*.sh files, and the $HOME/.bashrc file, the child shell for the script inherits 
  these exported variables.

It is a better idea to create a file ending with .sh in the /etc/profile.d/ directory. In that 
  file, place all your new or modified global environment variable settings.




â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Understanding Linux File Permissions
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
The /etc/passwd file
  The Linux system uses a special file to match the login name to a corresponding UID value. This file 
  is the /etc/passwd file. The /etc/passwd file contains several pieces of information about the user.
  root user account is the administrator for the Linux system and is always assigned UID 0

The Linux system creates lots of user accounts for various functions that aren't actual users. These 
  are called system accounts. A system account is a special account that services running on the 
  system use to gain access to resources on the system. All services that run in background mode 
  need to be logged into the Linux system under a system user account.

Linux reserves UIDs below 500 for system accounts. Some services even require specific UIDs to 
  work properly. When you create accounts for normal users, most Linux systems assign the first 
  available UID starting at 500 (although this is not necessarily true for all Linux distributions, 
  such as Ubuntu, which starts at 1000).

The fields of the /etc/passwd file contain the following information:
  The login username
  The password for the user (x which means it is encrypted)
  The numerical UID of the user account
  The numerical group ID (GID) of the user's primary group
  A text description of the user account (called the comment field)
  The location of the $HOME directory for the user
  The default shell for the user

Now, most Linux systems hold user passwords in a separate file (called the shadow file, located at 
  /etc/shadow). Only special programs (such as the login program) are allowed access to this file.

The /etc/shadow file
  The /etc/shadow file provides more control over how the Linux system manages passwords. Only the 
  root user has access to the /etc/shadow file, making it more secure than the /etc/passwd file.

Each /etc/shadow file record includes nine fields:
  The login name corresponding to the login name in the /etc/passwd file
  The encrypted password
  The day the password was last changed, depicted as the number of days
  since January 1, 1970
  The minimum number of days before the password can be changed
  The number of days before the password must be changed
  The number of days before password expiration that the user is warned to
  change the password
  The number of days after a password expires before the account will be
  disabled
  The date (stored as the number of days since January 1, 1970) since the user
  account was disabled
  A field reserved for future use


NOTE
  The default values for the useradd command are set using the /etc/default/useradd file. Also, 
  further security settings are defined in the /etc/login.defs file. You can tweak these files to
  change the default security behavior on your Linux system.

# useradd -D
  GROUP=100
  HOME=/home
  INACTIVE=-1
  EXPIRE=
  SHELL=/bin/bash
  SKEL=/etc/skel
  CREATE_MAIL_SPOOL=yes
#

The new user will be added to a common group with group ID 100.
The new user will have a HOME account created in the directory /home/loginname.
The account will not be disabled when the password expires.
The new account will not be set to expire at a set date.
The new account will use the bash shell as the default shell.
The system will copy the contents of the /etc/skel directory to the user's $HOME directory.
The system will create a file in the mail directory for the user account to receive mail.

For many Linux distributions the useradd command doesn't create a $HOME
  directory by default, but the â€“m command-line option tells it to create the
  $HOME directory. You can change that behavior within the /etc/login.defs file.
You can change the system default new user values by using the -D parameter, along 
  with a parameter representing the value you need to change
  
The usermod command is the most robust of the user account modification utilities.
  For usermod The parameters are mostly the same as the useradd parameters (such as -c to change the
  comment field, -e to change the expiration date, and -g to change the default login group). 
  However, a few additional parameters might come in handy:
-l to change the login name of the user account
-L to lock the account so the user can't log in
-p to change the password for the account
-U to unlock the account so that the user can log in

In the passwd The -e option is a handy way to force a user to change the password on the
  next login. This allows you to set the user's password to a simple value and
  then force them to change it to something harder that they can remember.

The /etc/group file
  Just like user accounts, group information is stored in a file on the system.
  The /etc/group file contains information about each group used on the system.

Like UIDs, GIDs are assigned using a special format. Groups used for system accounts are assigned GIDs 
  below 500, and user groups are assigned GIDs starting at 500. The /etc/group file uses four fields:
    The group name
    The group password
    The GID
    The list of user accounts that belong to the group
The group password allows a non-group member to temporarily become a member of the group by 
  using the password. This feature is not used all that commonly, but it does exist.

NOTE
  The list of user accounts is somewhat misleading. You'll notice that there are several groups in 
  the list that don't have any users listed. This isn't because they don't have any members. When 
  a user account uses a group as the primary group in the /etc/passwd file, the user account doesn't 
  appear in the /etc/group file as a member. This has caused confusion for more than one system 
  administrator over the years!

The umask value is just that, a mask. It masks out the permissions you don't want to give to the 
  security level. Now we have to dive into some octal arithmetic to figure out the rest of the 
  story. The umask value is subtracted from the full permission set for an object. The full 
  permission for a file is mode 666 (read/write permission for all), but for a directory it's 777 
  (read/write/execute permission for all). Thus, in the example, the file starts out with 
  permissions 666, and the umask of 022 is applied, leaving a file permission of 644.
  
i.e   umask 026  -> then:  touch newfile2   so the file permissions: -rw-r-----
  Because the default permissions for a directory are 777 (666 for files), the resulting permissions 
  from the umask are different from those of a new file. The 026 umask value is subtracted from 777, 
  leaving the 751 directory permission setting.
  

Changing permissions
  The chmod command allows you to change the security settings for files and
  directories. The format of the chmod command is:  chmod options mode file

. The following is the format for specifying a permission in symbolic mode:
  [ugoa...][[+-=][rwxXstugo...]
The first group of characters defines to whom the new permissions apply: 
    u for the user
    g for the group
    o for others (everyone else)
    a for all of the above
    
Next, a symbol is used to indicate whether you want to add the permission to the existing permissions 
  (+), subtract the permission from the existing permissions (âˆ’), or set the permissions to the 
  value (=). Finally, the third symbol is the permission used for the setting. You may notice that 
  there are more than the normal rwx values here. The additional settings are as follows:

X to assign execute permissions only if the object is a directory or if it already had execute permissions
s to set the SUID or SGID on execution
t to set the sticky bit
u to set the permissions to the owner's permissions
g to set the permissions to the group's permissions
o to set the permissions to the othersâ€™ permissions


The format of the chown command is:  chown options owner[.group] file
NOTE
  Only the root user can change the owner of a file. Any user can change the default group of 
  a file, but the user must be a member of the groups the file is changed from and to.

Linux stores three additional bits of information for each file and directory:

The set user ID (SUID): When a file is executed by a user, the program
  runs under the permissions of the file owner.
The set group ID (SGID): For a file, the program runs under the permissions of the file group. For 
  a directory, new files created in the directory use the directory group as the default group.
The sticky bit: When applied to a directory, only file owners can delete or
  rename the files in the directory.

The SGID bit is important for sharing files. By enabling the SGID bit, you can force all new 
  files created in a shared directory to be owned by the directory's group and now the individual 
  user's group. The SGID is set using the chmod command. It's added to the beginning of the standard 
  three-digit octal value (making a four-digit octal value), or you
  can use the symbol s in symbolic mode.

So, to create a shared directory that always sets the directory group for all
  new files, all you need to do is set the SGID bit for the directory:
$ mkdir testdir
$ chgrp shared testdir
$ chmod g+s testdir
$ umask 002
$ cd testdir
$ touch testfile
The first step is to create a directory that you want to share using the mkdir command. Next, the 
  chgrp command is used to change the default group for the directory to a group that contains the 
  members who need to share files. Finally, the SGID bit is set for the directory to ensure that 
  any files created in the directory use the shared group name as the default group. For this 
  environment to work properly, all of the group members need to have their umask values set to 
  make files writable by group members. In the preceding example, the umask is changed to 002 
  so that the files are writable by the group.

After all that's done, any member of the group can go to the shared directory and create a new 
  file. As expected, the new file USES THE DEFAULT GROUP OF THE DIRECTORY, not the user account's
  default group. Now any user in the shared group can access this file.

Linux developers have devised a more advanced method of file and directory security called an access 
  control list (ACL). The ACL allows you to specify a list of multiple user or groups, and the 
  permissions that are assigned to them. Just like the basic security method, ACL permissions use the 
  same read, write, and execute permission bits but can now be assigned to multiple users and groups.

The setfacl command allows you to modify the permissions assigned to a file or directory using the -m 
  option, or remove specific permissions using the -x option. You define the rule with three formats:
    u[ser]:uid:perms
    g[roup]:gid:perms
    o[ther]::perms

$ setfacl -m g:sales:rw test
$ ls -l   ->>       -rw-rw----+ 1 rich rich 0 Apr 19 17:33 test

Notice: there's no output from the setfacl command. When you list the file, only the standard 
  owner, group, and other permissions are shown, but note that there's a plus sign (+) added to 
  the permissions list. This indicates that the file has additional ACLs applied to it. To view the
  additional ACLs, use the getfacl command again:
$ getfacl test

# file: test
# owner: rich
# group: rich
# user::rw-
# group::r--
# group:sales:rw-
# mask::rw-
# other::---
The getfacl output now shows that there are permissions assigned to two groups. The default file group 
  (rich) is assigned read permissions, but now the sales group has read and write permissions to the file.


